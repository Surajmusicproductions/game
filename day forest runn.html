<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Runner Challenge</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #000; color: white; }
        #game-canvas { display: block; width: 100vw; height: 100vh; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; pointer-events: none; background: rgba(0,0,0,0.7); transition: opacity 0.5s ease; opacity: 1; }
        #ui-overlay.hidden { opacity: 0; pointer-events: none; }
        h1 { font-size: 4rem; margin-bottom: 1rem; text-shadow: 0 0 15px rgba(255, 255, 255, 0.7); }
        p { font-size: 1.3rem; max-width: 80%; }
        button { pointer-events: auto; font-size: 1.5rem; padding: 15px 30px; margin-top: 20px; background-color: #A0522D; color: white; border: 2px solid white; border-radius: 10px; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #8B4513; }

        /* In-Game UI for Score */
        #game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #high-score {
            font-size: 1rem;
            opacity: 0.8;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
        }
        .mobile-btn {
            pointer-events: auto;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: white;
            user-select: none;
            touch-action: manipulation;
        }

        .control-stack { display: flex; flex-direction: column-reverse; align-items: center; gap: 15px; }

        #perks-ui {
            position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }
        .perk-slot {
            width: 50px; height: 50px; background-color: rgba(0, 0, 0, 0.5); border: 2px solid white;
            border-radius: 10px; display: flex; justify-content: center; align-items: center;
            font-size: 1.5rem; color: white;
        }
        .perk-slot.active { background-color: rgba(0, 100, 0, 0.7); box-shadow: 0 0 10px rgba(0, 255, 0, 0.7); }

        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; } p { font-size: 1rem; }
            button { font-size: 1.2rem; padding: 12px 24px; }
            .mobile-btn { width: 70px; height: 70px; font-size: 1.8rem; }
            .perk-slot { width: 40px; height: 40px; font-size: 1.2rem; }
            #game-ui { font-size: 1.2rem; } #high-score { font-size: 0.9rem; }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <audio id="background-music" src="background_music.mpeg" loop></audio>

    <canvas id="game-canvas"></canvas>

    <div id="ui-overlay">
        <h1 id="ui-title">Forest Runner Challenge</h1>
        <p id="ui-instructions">Use <b>A / D</b> or <b>Left / Right</b> keys to dodge the obstacles.<br>
        Press <b>SPACE</b> to jump and <b>SHIFT</b> to crouch.<br>
        The forest grows more complex the further you run!</p>
        <button id="start-button">START RUNNING</button>
    </div>

    <div id="game-ui" style="display: none;">
        <div id="score">Score: 0</div>
        <div id="high-score">High Score: 0</div>
    </div>

    <div id="mobile-controls">
        <div class="control-stack">
            <div class="mobile-btn" id="crouch-btn">↓</div>
            <div class="mobile-btn" id="left-btn">←</div>
        </div>
        <div class="control-stack">
            <div class="mobile-btn" id="jump-btn">↑</div>
            <div class="mobile-btn" id="right-btn">→</div>
        </div>
    </div>

    <div id="perks-ui">
        <div class="perk-slot" id="collision-perk">3x</div>
        <div class="perk-slot" id="slow-perk">⌛</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- GAME STATE & CONFIG ---
        let gameRunning = false;
        const START_SPEED = 28.0;
        const ACCELERATION = 0.1;
        const LATERAL_SPEED = 22.0;
        let obstacleDensity = 1.0;

        let isJumping = false, isCrouching = false, jumpVelocity = 0;
        const JUMP_FORCE = 15, GRAVITY = -50, NORMAL_HEIGHT = 5, CROUCH_HEIGHT = 2.5;

        let collisionSkipCount = 0, slowTimeActive = false, slowTimeEndTime = 0;

        // COLLISION FIX: Add invincibility state
        let isInvincible = false;
        let invincibilityEndTime = 0;

        let score = 0, highScore = localStorage.getItem('forestRunnerHighScore') || 0, difficultyLevel = 0;

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const eveningColor = 0xFFA07A;
        scene.fog = new THREE.Fog(eveningColor, 75, 250);
        scene.background = new THREE.Color(eveningColor);

        const textureLoader = new THREE.TextureLoader();
        textureLoader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/sky14.jpg', function(texture) {
            scene.add(new THREE.Mesh(new THREE.SphereGeometry(800, 32, 20), new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide, fog: false })));
        });

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, NORMAL_HEIGHT, -10);
        camera.lookAt(0, NORMAL_HEIGHT, 0);

        const sun = new THREE.Mesh(new THREE.SphereGeometry(20, 32, 32), new THREE.MeshBasicMaterial({ color: 0xFFD700, fog: false }));
        sun.position.set(-200, 100, 400);
        scene.add(sun);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        scene.add(new THREE.AmbientLight(0xFFF8E7, 0.8));
        const mainLight = new THREE.DirectionalLight(0xFFE4B5, 1.8);
        mainLight.position.set(-150, 80, 100);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 1024; mainLight.shadow.mapSize.height = 1024;
        mainLight.shadow.camera.near = 0.5; mainLight.shadow.camera.far = 500;
        mainLight.shadow.camera.left = -100; mainLight.shadow.camera.right = 100;
        mainLight.shadow.camera.top = 100; mainLight.shadow.camera.bottom = -100;
        scene.add(mainLight);

        const player = { speed: START_SPEED, height: 1.8, hitbox: new THREE.Box3() };

        // --- WORLD GENERATION ---
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.9, metalness: 0.1 });
        const worldChunks = new Map();
        const CHUNK_SIZE = 50;
        const RENDER_DISTANCE = 3;

        function createWorldChunk(chunkX, chunkZ) {
            const chunkId = `${chunkX},${chunkZ}`;
            if (worldChunks.has(chunkId)) return;

            const chunkGroup = new THREE.Group();
            chunkGroup.userData = { obstacles: [], perks: [] };

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE), groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            chunkGroup.add(ground);

            addGroundDetails(chunkGroup);

            // COMPLEXITY CHANGE: Generate more complex patterns based on difficulty
            const obstacleCount = 1 + Math.floor(difficultyLevel / 2);
            for(let i = 0; i < obstacleCount; i++) {
                const x = Math.random() * CHUNK_SIZE - CHUNK_SIZE / 2;
                const z = Math.random() * CHUNK_SIZE - CHUNK_SIZE / 2;

                if (difficultyLevel < 2) { // Easy start
                    const tree = createRandomTree(x, z);
                    chunkGroup.add(tree);
                    chunkGroup.userData.obstacles.push(tree.children[0]);
                } else { // Increased complexity
                    const pattern = Math.random();
                    if (pattern < 0.35) { // Corridor
                        const tree1 = createRandomTree(x - 4, z);
                        const tree2 = createRandomTree(x + 4, z);
                        chunkGroup.add(tree1, tree2);
                        chunkGroup.userData.obstacles.push(tree1.children[0], tree2.children[0]);
                    } else if (pattern < 0.6) { // Forced jump
                        const log = createJumpingObstacle(x, z);
                        chunkGroup.add(log);
                        chunkGroup.userData.obstacles.push(log);
                    } else if (pattern < 0.8 && difficultyLevel >= 4) { // Compound Obstacle
                         const log = createJumpingObstacle(x, z);
                         const tree = createRandomTree(x + (Math.random() > 0.5 ? 3 : -3), z + 5);
                         chunkGroup.add(log, tree);
                         chunkGroup.userData.obstacles.push(log, tree.children[0]);
                    }
                    else { // Random complex tree
                        const tree = createRandomTree(x, z, true); // Pass true to make it complex
                        chunkGroup.add(tree);
                        chunkGroup.userData.obstacles.push(tree.children[0]);
                         if (tree.children.length > 2) { // If it has extra branches
                            chunkGroup.userData.obstacles.push(tree.children[2]);
                        }
                    }
                }
            }

            if (Math.random() < 0.1) {
                const perk = createPerk(Math.random() > 0.5 ? 'collision' : 'slow', Math.random() * CHUNK_SIZE - CHUNK_SIZE / 2, Math.random() * CHUNK_SIZE - CHUNK_SIZE / 2);
                chunkGroup.add(perk);
                chunkGroup.userData.perks.push(perk);
            }

            const foliageCount = Math.floor((Math.random() * 4 + 2) * obstacleDensity);
            for (let i = 0; i < foliageCount; i++) {
                const foliage = createBush();
                foliage.position.set(Math.random() * CHUNK_SIZE - CHUNK_SIZE / 2, foliage.position.y, Math.random() * CHUNK_SIZE - CHUNK_SIZE / 2);
                chunkGroup.add(foliage);
            }

            chunkGroup.position.set(chunkX * CHUNK_SIZE, 0, chunkZ * CHUNK_SIZE);
            scene.add(chunkGroup);
            worldChunks.set(chunkId, chunkGroup);
        }

        function addGroundDetails(chunkGroup) {
             const detailCount = Math.floor(Math.random() * 5) + 3;
            for (let i = 0; i < detailCount; i++) {
                const detail = createSmallRock();
                detail.position.set( Math.random() * CHUNK_SIZE - CHUNK_SIZE / 2, detail.position.y, Math.random() * CHUNK_SIZE - CHUNK_SIZE / 2);
                chunkGroup.add(detail);
            }
        }

        // --- ASSET CREATION ---
        const treeMaterials = {
            standard: { trunk: new THREE.MeshStandardMaterial({ color: 0x8B4513 }), leaves: new THREE.MeshStandardMaterial({ color: 0x228B22 }) },
            autumn: { trunk: new THREE.MeshStandardMaterial({ color: 0x6e472d }), leaves: new THREE.MeshStandardMaterial({ color: 0xCD5C5C }) },
            birch: { trunk: new THREE.MeshStandardMaterial({ color: 0xF5F5DC }), leaves: new THREE.MeshStandardMaterial({ color: 0x9ACD32 }) }
        };
        const stoneMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.8 });
        const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x6B8E23 });

        function createSmallRock() {
            const rockSize = Math.random() * 0.5 + 0.2;
            const rock = new THREE.Mesh(new THREE.IcosahedronGeometry(rockSize, 0), stoneMaterial);
            rock.position.y = rockSize / 2;
            return rock;
        }
        function createBush() {
            const bushSize = Math.random() * 1.5 + 0.5;
            const bush = new THREE.Mesh(new THREE.IcosahedronGeometry(bushSize, 0), bushMaterial);
            bush.position.y = bushSize / 2;
            bush.castShadow = true;
            return bush;
        }

        function createRandomTree(x, z, isComplex = false) {
            const tree = new THREE.Group();
            const type = Math.random();
            let materials;
            if (type < 0.6) materials = treeMaterials.standard;
            else if (type < 0.85) materials = treeMaterials.autumn;
            else materials = treeMaterials.birch;

            const height = Math.random() * 8 + 10;
            const trunkRadius = (isComplex ? 1.5 : 1) * (Math.random() * 0.3 + 0.4);
            const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, height, 6);
            const trunk = new THREE.Mesh(trunkGeo, materials.trunk);
            trunk.position.y = height / 2;

            const leafGeo = new THREE.IcosahedronGeometry(Math.random() * 2 + (isComplex ? 4 : 3), 0);
            const leaves = new THREE.Mesh(leafGeo, materials.leaves);
            leaves.position.y = height;

            trunk.castShadow = true;
            leaves.castShadow = true;
            tree.add(trunk, leaves);

            if (isComplex && Math.random() > 0.5) {
                const branchGeo = new THREE.CylinderGeometry(0.2, 0.3, 5, 5);
                const branch = new THREE.Mesh(branchGeo, materials.trunk);
                branch.position.set(trunkRadius, height * 0.6, 0);
                branch.rotation.z = Math.PI / 4;
                branch.castShadow = true;
                tree.add(branch);
                branch.userData = { isObstacle: true, hitbox: new THREE.Box3().setFromObject(branch) };
            }

            trunk.userData = { isObstacle: true, hitbox: new THREE.Box3().setFromObject(trunk) };
            tree.position.set(x, 0, z);
            return tree;
        }

        function createJumpingObstacle(x, z) {
            const log = new THREE.Mesh( new THREE.CylinderGeometry(0.5, 0.5, 4, 6).rotateZ(Math.PI / 2), treeMaterials.standard.trunk);
            log.castShadow = true;
            log.userData = { isObstacle: true, requiresJump: true, hitbox: new THREE.Box3().setFromObject(log) };
            log.position.set(x, 0.5, z);
            return log;
        }

        function createCrouchingObstacle(x, z) {
            const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 6, 6).rotateX(Math.PI / 2), treeMaterials.standard.trunk);
            branch.castShadow = true;
            branch.userData = { isObstacle: true, requiresCrouch: true, hitbox: new THREE.Box3().setFromObject(branch) };
            branch.position.set(x, 2.5, z);
            return branch;
        }

        function createPerk(type, x, z) {
            let geo, mat;
            if (type === 'collision') { geo = new THREE.OctahedronGeometry(1); mat = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); }
            else { geo = new THREE.TorusGeometry(0.8, 0.3, 8, 12); mat = new THREE.MeshStandardMaterial({ color: 0x4444ff }); }
            const perk = new THREE.Mesh(geo, mat);
            perk.userData = { isPerk: true, perkType: type, hitbox: new THREE.Box3().setFromObject(perk) };
            perk.position.set(x, 1.5, z);
            return perk;
        }

        // --- CONTROLS ---
        // FIXED: Restored the controls object and event listeners
        const controls = { moveLeft: false, moveRight: false, jump: false, crouch: false };
        document.addEventListener('keydown', (e) => {
            if (e.key === 'a' || e.key === 'ArrowLeft') controls.moveLeft = true;
            if (e.key === 'd' || e.key === 'ArrowRight') controls.moveRight = true;
            if (e.key === ' ' && !isJumping && !isCrouching) { isJumping = true; jumpVelocity = JUMP_FORCE; }
            if (e.key === 'Shift' && !isJumping) { isCrouching = true; camera.position.y = CROUCH_HEIGHT; }
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'a' || e.key === 'ArrowLeft') controls.moveLeft = false;
            if (e.key === 'd' || e.key === 'ArrowRight') controls.moveRight = false;
            if (e.key === 'Shift') { isCrouching = false; if (!isJumping) camera.position.y = NORMAL_HEIGHT; }
        });
        const leftBtn = document.getElementById('left-btn'); const rightBtn = document.getElementById('right-btn');
        const jumpBtn = document.getElementById('jump-btn'); const crouchBtn = document.getElementById('crouch-btn');
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); controls.moveLeft = true; });
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); controls.moveLeft = false; });
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); controls.moveRight = true; });
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); controls.moveRight = false; });
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isJumping && !isCrouching) { isJumping = true; jumpVelocity = JUMP_FORCE; } });
        crouchBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (!isJumping) { isCrouching = true; camera.position.y = CROUCH_HEIGHT; } });
        crouchBtn.addEventListener('touchend', (e) => { e.preventDefault(); isCrouching = false; if(!isJumping) camera.position.y = NORMAL_HEIGHT; });

        // --- UI & GAME STATE ---
        const uiOverlay = document.getElementById('ui-overlay'), uiTitle = document.getElementById('ui-title'),
              uiInstructions = document.getElementById('ui-instructions'), startButton = document.getElementById('start-button'),
              gameUI = document.getElementById('game-ui'), scoreUI = document.getElementById('score'),
              highScoreUI = document.getElementById('high-score'), collisionPerkUI = document.getElementById('collision-perk'),
              slowPerkUI = document.getElementById('slow-perk');

        startButton.addEventListener('click', () => { gameRunning = true; uiOverlay.classList.add('hidden'); gameUI.style.display = 'block'; resetGame(); });

        function gameOver() {
            gameRunning = false;
            uiTitle.innerText = "Game Over";
            uiInstructions.innerHTML = `You ran ${score} meters!<br>High Score: ${highScore}`;
            startButton.innerText = "RUN AGAIN";
            uiOverlay.classList.remove('hidden');
            gameUI.style.display = 'none';
        }
        function resetGame() {
            camera.position.set(0, NORMAL_HEIGHT, -10); player.speed = START_SPEED;
            obstacleDensity = 1.0; isJumping = false; isCrouching = false;
            jumpVelocity = 0; collisionSkipCount = 0; slowTimeActive = false;
            isInvincible = false; score = 0; difficultyLevel = 0;
            updatePerkUI();
            highScoreUI.innerText = `High Score: ${highScore}`;
            worldChunks.forEach(chunk => scene.remove(chunk)); worldChunks.clear();
        }
        function updatePerkUI() {
            collisionPerkUI.classList.toggle('active', collisionSkipCount > 0);
            collisionPerkUI.innerText = collisionSkipCount > 0 ? `${collisionSkipCount}x` : '3x';
            slowPerkUI.classList.toggle('active', slowTimeActive);
        }

        // --- GAME LOOP ---
        const clock = new THREE.Clock();
        const tempHitbox = new THREE.Box3();

        function animate() {
            requestAnimationFrame(animate);
            if (!gameRunning) return;

            const delta = clock.getDelta();
            const currentTime = clock.getElapsedTime();

            score = Math.floor(camera.position.z);
            if (score > highScore) { highScore = score; localStorage.setItem('forestRunnerHighScore', highScore); }
            scoreUI.innerText = `Score: ${score}`; highScoreUI.innerText = `High Score: ${highScore}`;
            difficultyLevel = Math.floor(score / 400);

            if (isInvincible && currentTime > invincibilityEndTime) { isInvincible = false; }

            let speedMultiplier = 1.0;
            if (slowTimeActive && currentTime < slowTimeEndTime) { speedMultiplier = 0.5; }
            else if (slowTimeActive) { slowTimeActive = false; updatePerkUI(); }

            camera.position.z += player.speed * delta * speedMultiplier;

            // FIXED: Restored jumping logic
            if (isJumping) {
                camera.position.y += jumpVelocity * delta;
                jumpVelocity += GRAVITY * delta;
                if (camera.position.y <= NORMAL_HEIGHT) {
                    camera.position.y = NORMAL_HEIGHT;
                    isJumping = false;
                }
            }

            const lateralVelocity = (controls.moveRight ? 1 : 0) - (controls.moveLeft ? 1 : 0);
            camera.position.x += lateralVelocity * LATERAL_SPEED * delta * speedMultiplier;
            camera.position.x = Math.max(-20, Math.min(20, camera.position.x));

            const camChunkX = Math.floor(camera.position.x / CHUNK_SIZE);
            const camChunkZ = Math.floor(camera.position.z / CHUNK_SIZE);

            for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) { for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) { createWorldChunk(camChunkX + x, camChunkZ + z); } }

            // FIXED: Restored chunk removal logic
            worldChunks.forEach((chunk, chunkId) => {
                 const [cx, cz] = chunkId.split(',').map(Number);
                if (Math.abs(cx - camChunkX) > RENDER_DISTANCE + 1 || Math.abs(cz - camChunkZ) > RENDER_DISTANCE + 1) {
                    scene.remove(chunk); worldChunks.delete(chunkId);
                }
            });

            const hitboxHeight = isCrouching ? player.height * 0.6 : player.height;
            player.hitbox.setFromCenterAndSize(
                new THREE.Vector3(camera.position.x, camera.position.y - NORMAL_HEIGHT + hitboxHeight/2, camera.position.z),
                new THREE.Vector3(2, hitboxHeight, 2)
            );

            let collisionDetected = false;
            if (!isInvincible) {
                for (let z = -1; z <= 1 && !collisionDetected; z++) {
                    for (let x = -1; x <= 1 && !collisionDetected; x++) {
                        const chunk = worldChunks.get(`${camChunkX + x},${camChunkZ + z}`);
                        if (chunk) {
                            for(const obstacle of chunk.userData.obstacles){
                                obstacle.updateWorldMatrix(true, false);
                                tempHitbox.copy(obstacle.userData.hitbox).applyMatrix4(obstacle.matrixWorld);
                                if (player.hitbox.intersectsBox(tempHitbox)) {
                                    if ((obstacle.userData.requiresJump && !isJumping) || (obstacle.userData.requiresCrouch && !isCrouching) || (!obstacle.userData.requiresJump && !obstacle.userData.requiresCrouch)) {
                                        collisionDetected = true; break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if(collisionDetected) {
                if (collisionSkipCount > 0) {
                    collisionSkipCount--;
                    updatePerkUI();
                    isInvincible = true;
                    invincibilityEndTime = currentTime + 0.5;
                } else {
                    gameOver();
                }
            }

            // FIXED: Restored perk collection logic
            let perkCollected = false;
            for (let z = -1; z <= 1 && !perkCollected; z++) {
                for (let x = -1; x <= 1 && !perkCollected; x++) {
                    const chunk = worldChunks.get(`${camChunkX + x},${camChunkZ + z}`);
                    if (chunk) {
                        for (const perk of [...chunk.userData.perks]) {
                             perk.updateWorldMatrix(true, false);
                             tempHitbox.copy(perk.userData.hitbox).applyMatrix4(perk.matrixWorld);
                             if(player.hitbox.intersectsBox(tempHitbox)){
                                if(perk.userData.perkType === 'collision') collisionSkipCount = 3;
                                else { slowTimeActive = true; slowTimeEndTime = clock.getElapsedTime() + 5; }
                                chunk.remove(perk);
                                chunk.userData.perks = chunk.userData.perks.filter(p => p !== perk);
                                perkCollected = true; updatePerkUI(); break;
                             }
                        }
                    }
                }
            }

            player.speed += ACCELERATION * delta * speedMultiplier;
            obstacleDensity = 1.0 + (score / 5000);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
             camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <script src="audio.js"></script>
</body>
</html>
